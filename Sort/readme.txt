本例程为排序算法例程，支持各种排序的算法

1.selectSort排序算法原理

1)首先，从第一个元素开始，分别与该元素之后的元素比较，找出该元素之后的最小值，然后于第一个元素交换。

2)偏移到第二个元素，重复1)，直到所有元素交换完毕。

3)算法性能分析

(1)对于长度为N的数组

  需要比较 (N-1) + (N-2) + (N-3) + ... + 1 = N(N-1)/2次；

  需要交换 N次;

(2）优点：交换次数少，数据移动不频繁。

(3) 缺点: 比较次数多，对于输入不敏感，任何序列必定会经过N（N-1）/2次的比较。

从右边开始排序

2.insertSort排序算法原理

1)首先，从第一个元素开始一直到最后一个元素开始循环，在每一次循环中，还未排序的该元素的左边序列为局部有序序列，将该元素分别

  从局部有序序列的最后一个元素开始，逐高到低，进行比较，如果该元素小于有序序列的元素，那么互相交换，直到大于有序序列的元素。

2)算法性能分析
  
(1)优点: 相比选择排序，比较次数少，而且对于有序或者部分有序的输入序列，交换的次数将会减少，而选择排序交换次数不会减少。

(2)缺点: 交换次数比较多。

从左边开始排序

因此对于有序序列来说，选择insertSort要优于selectSort，交换次数会减少。

3)insertSort排序算法的优化，采用shellSort，这里用到了"分治"的思想，把一个大任务的解决问题，用到小任务中，进行简化。

shellSort的思想就是:通过改变每次insertSort的步长，把对原始序列的选择排序问题转换成小的子序列的选择排序问题，这样做的好处是，

元素交换时移动的位置可以更大些，间接地减少了移动的次数。然后将步长逐渐缩小到1，转换为插入排序算法，不过这时步长为1的插入排序

算法，和传统的选择排序问题相比，序列由于分治的操作进行了改变，相当于对原始序列进行一个类传统选择排序化，这样的话细化到步长

为1的插入排序，交换的次数会减少，达到算法优化的目的。

3.mergeSort归并排序

1)归并排序的思想类似于希尔排序，同样利用了分治的思想。

  归并递归实现的算法原理:比如一个序列排序，可以把一个序列分为两个子序列，然后首先把这两个子序列排序好，最后将这两个子序列融合

  也称归并到一起整体排序。这样一直递归下去，直到分为的两个子序列的元素只含有一个。

  递归过程:从上到下,从大分治到小  
  
  递归返回过程:从下到上，从小并到大

2)归并非递归实现的算法原理:与递归实现原理相反，把大序列先分到最小，把一个大序列分为只含一个元素的小序列。

  然后把相邻的两组子序列进行排序，这样每组都是1个元素的小序列经过一次迭代就会归并到每组大于等于1个元素的较大序列，这样迭代

  下去，直到整个序列排序完毕。  



